"use strict";(self.webpackChunklearn_data=self.webpackChunklearn_data||[]).push([[4304],{9874:(n,s)=>{s.A=(n,s)=>{const a=n.__vccOpts||n;for(const[n,i]of s)a[n]=i;return a}},2261:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>p,data:()=>r});var i=a(2360);const e=[(0,i.Fv)('<h1 id="归并排序" tabindex="-1"><a class="header-anchor" href="#归并排序"><span>归并排序</span></a></h1><h2 id="介绍" tabindex="-1"><a class="header-anchor" href="#介绍"><span>介绍</span></a></h2><p><strong>归并排序</strong>（<em>Merge Sort</em>)是一种基于分治法的排序算法。它的主要思想是将一个大的问题分解成若干个小问题来解决，然后将解决的结果合并在一起。归并排序的时间复杂度为 𝑂(𝑛log𝑛),是效率较高的排序算法之一。</p><h2 id="代码" tabindex="-1"><a class="header-anchor" href="#代码"><span>代码</span></a></h2><h3 id="迭代" tabindex="-1"><a class="header-anchor" href="#迭代"><span>迭代</span></a></h3><ol><li>C</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;stdio.h&gt;</span></span>\n<span class="line"><span>#include &lt;stdlib.h&gt;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>int min(int x, int y)</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    return x &lt; y ? x : y;</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>void merge_sort(int arr[], int len)</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    int *a = arr;</span></span>\n<span class="line"><span>    int *b = (int *)malloc(len * sizeof(int));</span></span>\n<span class="line"><span>    if (b == NULL)</span></span>\n<span class="line"><span>    {</span></span>\n<span class="line"><span>        fprintf(stderr, &quot;Memory allocation failed\\n&quot;);</span></span>\n<span class="line"><span>        return;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    int seg, start;</span></span>\n<span class="line"><span>    for (seg = 1; seg &lt; len; seg += seg)</span></span>\n<span class="line"><span>    {</span></span>\n<span class="line"><span>        for (start = 0; start &lt; len; start += seg + seg)</span></span>\n<span class="line"><span>        {</span></span>\n<span class="line"><span>            int low = start, mid = min(start + seg, len), high = min(start + 2 * seg, len);</span></span>\n<span class="line"><span>            int k = low;</span></span>\n<span class="line"><span>            int start1 = low, end1 = mid;</span></span>\n<span class="line"><span>            int start2 = mid, end2 = high;</span></span>\n<span class="line"><span>            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span></span>\n<span class="line"><span>                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span></span>\n<span class="line"><span>            while (start1 &lt; end1)</span></span>\n<span class="line"><span>                b[k++] = a[start1++];</span></span>\n<span class="line"><span>            while (start2 &lt; end2)</span></span>\n<span class="line"><span>                b[k++] = a[start2++];</span></span>\n<span class="line"><span>        }</span></span>\n<span class="line"><span>        int *temp = a;</span></span>\n<span class="line"><span>        a = b;</span></span>\n<span class="line"><span>        b = temp;</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    if (a != arr)</span></span>\n<span class="line"><span>    {</span></span>\n<span class="line"><span>        for (int i = 0; i &lt; len; i++)</span></span>\n<span class="line"><span>            arr[i] = a[i];</span></span>\n<span class="line"><span>    }</span></span>\n<span class="line"><span>    free(b);</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>int main()</span></span>\n<span class="line"><span>{</span></span>\n<span class="line"><span>    int arr[] = {22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70};</span></span>\n<span class="line"><span>    int len = sizeof(arr) / sizeof(*arr);</span></span>\n<span class="line"><span>    merge_sort(arr, len);</span></span>\n<span class="line"><span>    for (int i = 0; i &lt; len; i++)</span></span>\n<span class="line"><span>        printf(&quot;%d &quot;, arr[i]);</span></span>\n<span class="line"><span>    printf(&quot;\\n&quot;);</span></span>\n<span class="line"><span>    return 0;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>Python</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>def min(x, y):</span></span>\n<span class="line"><span>    return x if x &lt; y else y</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>def merge_sort(arr):</span></span>\n<span class="line"><span>    n = len(arr)</span></span>\n<span class="line"><span>    a = arr[:]</span></span>\n<span class="line"><span>    b = [0] * n</span></span>\n<span class="line"><span>    seg = 1</span></span>\n<span class="line"><span>    while seg &lt; n:</span></span>\n<span class="line"><span>        for start in range(0, n, seg + seg):</span></span>\n<span class="line"><span>            low = start</span></span>\n<span class="line"><span>            mid = min(start + seg, n)</span></span>\n<span class="line"><span>            high = min(start + seg + seg, n)</span></span>\n<span class="line"><span>            k = low</span></span>\n<span class="line"><span>            start1 = low</span></span>\n<span class="line"><span>            end1 = mid</span></span>\n<span class="line"><span>            start2 = mid</span></span>\n<span class="line"><span>            end2 = high</span></span>\n<span class="line"><span>            while start1 &lt; end1 and start2 &lt; end2:</span></span>\n<span class="line"><span>                if a[start1] &lt; a[start2]:</span></span>\n<span class="line"><span>                    b[k] = a[start1]</span></span>\n<span class="line"><span>                    start1 += 1</span></span>\n<span class="line"><span>                else:</span></span>\n<span class="line"><span>                    b[k] = a[start2]</span></span>\n<span class="line"><span>                    start2 += 1</span></span>\n<span class="line"><span>                k += 1</span></span>\n<span class="line"><span>            while start1 &lt; end1:</span></span>\n<span class="line"><span>                b[k] = a[start1]</span></span>\n<span class="line"><span>                start1 += 1</span></span>\n<span class="line"><span>                k += 1</span></span>\n<span class="line"><span>            while start2 &lt; end2:</span></span>\n<span class="line"><span>                b[k] = a[start2]</span></span>\n<span class="line"><span>                start2 += 1</span></span>\n<span class="line"><span>                k += 1</span></span>\n<span class="line"><span>        a, b = b, a</span></span>\n<span class="line"><span>        seg += seg</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    if a != arr:</span></span>\n<span class="line"><span>        for i in range(n):</span></span>\n<span class="line"><span>            arr[i] = a[i]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>arr = [38, 27, 43, 3, 9, 82, 10]</span></span>\n<span class="line"><span>merge_sort(arr)</span></span>\n<span class="line"><span>print(arr)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><h4 id="分析" tabindex="-1"><a class="header-anchor" href="#分析"><span>分析</span></a></h4></li></ol><p>先将数组分为1个为一组，分了7组， 再1，2；3，4；5，6；7；两两比较，给比较的两组定义一个指针，指针所指的值相互比较, 也就是在这个块<code>while start1 &lt; end1 and start2 &lt; end2</code>进行，小的值排左边，直到有一组的指针指向了末尾；如果剩的是第一组的就调用<code>while start1 &lt; end1</code>这个块，否则调用<code>while start2 &lt; end2</code>这个块。以此类推，分成4组， 分成2组......最终得到有序的数列。</p><h2 id="递归" tabindex="-1"><a class="header-anchor" href="#递归"><span>递归</span></a></h2><ol><li>C</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;stdio.h&gt;</span></span>\n<span class="line"><span>#include &lt;stdlib.h&gt; // 加入此行以便使用 malloc 和 free</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>void merge_sort_recursive(int arr[], int reg[], int start, int end) {</span></span>\n<span class="line"><span>    if (start &gt;= end)</span></span>\n<span class="line"><span>        return;</span></span>\n<span class="line"><span>    int len = end - start, mid = (len &gt;&gt; 1) + start;</span></span>\n<span class="line"><span>    int start1 = start, end1 = mid;</span></span>\n<span class="line"><span>    int start2 = mid + 1, end2 = end;</span></span>\n<span class="line"><span>    merge_sort_recursive(arr, reg, start1, end1);</span></span>\n<span class="line"><span>    merge_sort_recursive(arr, reg, start2, end2);</span></span>\n<span class="line"><span>    int k = start;</span></span>\n<span class="line"><span>    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)</span></span>\n<span class="line"><span>        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];</span></span>\n<span class="line"><span>    while (start1 &lt;= end1)</span></span>\n<span class="line"><span>        reg[k++] = arr[start1++];</span></span>\n<span class="line"><span>    while (start2 &lt;= end2)</span></span>\n<span class="line"><span>        reg[k++] = arr[start2++];</span></span>\n<span class="line"><span>    for (k = start; k &lt;= end; k++)</span></span>\n<span class="line"><span>        arr[k] = reg[k];</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span>void merge_sort(int arr[], const int len) {</span></span>\n<span class="line"><span>    int reg[len];</span></span>\n<span class="line"><span>    merge_sort_recursive(arr, reg, 0, len - 1);</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>int main() {</span></span>\n<span class="line"><span>    int arr[] = { 22, 34, 3, 32, 82, 55, 89 };</span></span>\n<span class="line"><span>    int len = sizeof(arr) / sizeof(*arr);</span></span>\n<span class="line"><span>    merge_sort(arr, len);</span></span>\n<span class="line"><span>    for (int i = 0; i &lt; len; i++)</span></span>\n<span class="line"><span>        printf(&quot;%d &quot;, arr[i]);</span></span>\n<span class="line"><span>    printf(&quot;\\n&quot;); // 增加换行以美化输出</span></span>\n<span class="line"><span>    return 0;</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>Python</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>def merge_sort_recursive(arr, reg, start, end):</span></span>\n<span class="line"><span>    if start &gt;= end:</span></span>\n<span class="line"><span>        return</span></span>\n<span class="line"><span>    mid = (start + end) // 2</span></span>\n<span class="line"><span>    merge_sort_recursive(arr, reg, start, mid)</span></span>\n<span class="line"><span>    merge_sort_recursive(arr, reg, mid + 1, end)</span></span>\n<span class="line"><span>    start1, end1 = start, mid</span></span>\n<span class="line"><span>    start2, end2 = mid + 1, end</span></span>\n<span class="line"><span>    k = start</span></span>\n<span class="line"><span>    while start1 &lt;= end1 and start2 &lt;= end2:</span></span>\n<span class="line"><span>        if arr[start1] &lt; arr[start2]:</span></span>\n<span class="line"><span>            reg[k] = arr[start1]</span></span>\n<span class="line"><span>            start1 += 1</span></span>\n<span class="line"><span>        else:</span></span>\n<span class="line"><span>            reg[k] = arr[start2]</span></span>\n<span class="line"><span>            start2 += 1</span></span>\n<span class="line"><span>        k += 1</span></span>\n<span class="line"><span>    while start1 &lt;= end1:</span></span>\n<span class="line"><span>        reg[k] = arr[start1]</span></span>\n<span class="line"><span>        start1 += 1</span></span>\n<span class="line"><span>        k += 1</span></span>\n<span class="line"><span>    while start2 &lt;= end2:</span></span>\n<span class="line"><span>        reg[k] = arr[start2]</span></span>\n<span class="line"><span>        start2 += 1</span></span>\n<span class="line"><span>        k += 1</span></span>\n<span class="line"><span>    for k in range(start, end + 1):</span></span>\n<span class="line"><span>        arr[k] = reg[k]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>def merge_sort(arr):</span></span>\n<span class="line"><span>    reg = [0] * len(arr)</span></span>\n<span class="line"><span>    merge_sort_recursive(arr, reg, 0, len(arr) - 1)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span># 示例使用</span></span>\n<span class="line"><span>arr = [22, 34, 3, 32, 82, 55, 89]</span></span>\n<span class="line"><span>merge_sort(arr)</span></span>\n<span class="line"><span>print(arr)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><h3 id="分析-1" tabindex="-1"><a class="header-anchor" href="#分析-1"><span>分析</span></a></h3></li></ol><p>逻辑和迭代法差不多。</p>',18)],l={},p=(0,a(9874).A)(l,[["render",function(n,s){return(0,i.uX)(),(0,i.CE)("div",null,e)}]]),r=JSON.parse('{"path":"/code/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html","title":"归并排序","lang":"zh-CN","frontmatter":{"title":"归并排序","date":"2024-07-16T00:00:00.000Z","category":["代码编程","算法"],"tag":["算法"],"sticky":true,"star":true,"order":-1,"description":"归并排序 介绍 归并排序（Merge Sort)是一种基于分治法的排序算法。它的主要思想是将一个大的问题分解成若干个小问题来解决，然后将解决的结果合并在一起。归并排序的时间复杂度为 𝑂(𝑛log𝑛),是效率较高的排序算法之一。 代码 迭代 C Python 分析 先将数组分为1个为一组，分了7组， 再1，2；3，4；5，6；7；两两比较，给比较的...","head":[["meta",{"property":"og:url","content":"https://newzone.top/code/%E7%AE%97%E6%B3%95/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html"}],["meta",{"property":"og:site_name","content":"LuoThink"}],["meta",{"property":"og:title","content":"归并排序"}],["meta",{"property":"og:description","content":"归并排序 介绍 归并排序（Merge Sort)是一种基于分治法的排序算法。它的主要思想是将一个大的问题分解成若干个小问题来解决，然后将解决的结果合并在一起。归并排序的时间复杂度为 𝑂(𝑛log𝑛),是效率较高的排序算法之一。 代码 迭代 C Python 分析 先将数组分为1个为一组，分了7组， 再1，2；3，4；5，6；7；两两比较，给比较的..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-16T07:12:42.000Z"}],["meta",{"property":"article:author","content":"LearnData"}],["meta",{"property":"article:tag","content":"算法"}],["meta",{"property":"article:published_time","content":"2024-07-16T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-16T07:12:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"归并排序\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-16T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-16T07:12:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"LearnData\\",\\"url\\":\\"https://newzone.top\\"}]}"]]},"headers":[{"level":2,"title":"介绍","slug":"介绍","link":"#介绍","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[{"level":3,"title":"迭代","slug":"迭代","link":"#迭代","children":[]}]},{"level":2,"title":"递归","slug":"递归","link":"#递归","children":[]}],"git":{"createdTime":1721113962000,"updatedTime":1721113962000,"contributors":[{"name":"luojunll","email":"l3228414338@gmail.com","commits":1}]},"readingTime":{"minutes":2.94,"words":881},"filePathRelative":"code/算法/归并排序.md","localizedDate":"2024年7月16日","excerpt":"\\n<h2>介绍</h2>\\n<p><strong>归并排序</strong>（<em>Merge Sort</em>)是一种基于分治法的排序算法。它的主要思想是将一个大的问题分解成若干个小问题来解决，然后将解决的结果合并在一起。归并排序的时间复杂度为 𝑂(𝑛log𝑛),是效率较高的排序算法之一。</p>\\n<h2>代码</h2>\\n<h3>迭代</h3>\\n<ol>\\n<li>C</li>\\n</ol>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes github-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>#include &lt;stdio.h&gt;</span></span>\\n<span class=\\"line\\"><span>#include &lt;stdlib.h&gt;</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>int min(int x, int y)</span></span>\\n<span class=\\"line\\"><span>{</span></span>\\n<span class=\\"line\\"><span>    return x &lt; y ? x : y;</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>void merge_sort(int arr[], int len)</span></span>\\n<span class=\\"line\\"><span>{</span></span>\\n<span class=\\"line\\"><span>    int *a = arr;</span></span>\\n<span class=\\"line\\"><span>    int *b = (int *)malloc(len * sizeof(int));</span></span>\\n<span class=\\"line\\"><span>    if (b == NULL)</span></span>\\n<span class=\\"line\\"><span>    {</span></span>\\n<span class=\\"line\\"><span>        fprintf(stderr, \\"Memory allocation failed\\\\n\\");</span></span>\\n<span class=\\"line\\"><span>        return;</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    int seg, start;</span></span>\\n<span class=\\"line\\"><span>    for (seg = 1; seg &lt; len; seg += seg)</span></span>\\n<span class=\\"line\\"><span>    {</span></span>\\n<span class=\\"line\\"><span>        for (start = 0; start &lt; len; start += seg + seg)</span></span>\\n<span class=\\"line\\"><span>        {</span></span>\\n<span class=\\"line\\"><span>            int low = start, mid = min(start + seg, len), high = min(start + 2 * seg, len);</span></span>\\n<span class=\\"line\\"><span>            int k = low;</span></span>\\n<span class=\\"line\\"><span>            int start1 = low, end1 = mid;</span></span>\\n<span class=\\"line\\"><span>            int start2 = mid, end2 = high;</span></span>\\n<span class=\\"line\\"><span>            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span></span>\\n<span class=\\"line\\"><span>                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span></span>\\n<span class=\\"line\\"><span>            while (start1 &lt; end1)</span></span>\\n<span class=\\"line\\"><span>                b[k++] = a[start1++];</span></span>\\n<span class=\\"line\\"><span>            while (start2 &lt; end2)</span></span>\\n<span class=\\"line\\"><span>                b[k++] = a[start2++];</span></span>\\n<span class=\\"line\\"><span>        }</span></span>\\n<span class=\\"line\\"><span>        int *temp = a;</span></span>\\n<span class=\\"line\\"><span>        a = b;</span></span>\\n<span class=\\"line\\"><span>        b = temp;</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    if (a != arr)</span></span>\\n<span class=\\"line\\"><span>    {</span></span>\\n<span class=\\"line\\"><span>        for (int i = 0; i &lt; len; i++)</span></span>\\n<span class=\\"line\\"><span>            arr[i] = a[i];</span></span>\\n<span class=\\"line\\"><span>    }</span></span>\\n<span class=\\"line\\"><span>    free(b);</span></span>\\n<span class=\\"line\\"><span>}</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>int main()</span></span>\\n<span class=\\"line\\"><span>{</span></span>\\n<span class=\\"line\\"><span>    int arr[] = {22, 34, 3, 32, 82, 55, 89, 50, 37, 5, 64, 35, 9, 70};</span></span>\\n<span class=\\"line\\"><span>    int len = sizeof(arr) / sizeof(*arr);</span></span>\\n<span class=\\"line\\"><span>    merge_sort(arr, len);</span></span>\\n<span class=\\"line\\"><span>    for (int i = 0; i &lt; len; i++)</span></span>\\n<span class=\\"line\\"><span>        printf(\\"%d \\", arr[i]);</span></span>\\n<span class=\\"line\\"><span>    printf(\\"\\\\n\\");</span></span>\\n<span class=\\"line\\"><span>    return 0;</span></span>\\n<span class=\\"line\\"><span>}</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);